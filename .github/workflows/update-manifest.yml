name: Update Manifest (No Redeploy)
permissions:
  contents: read

# This workflow sends a manifest update to an EXISTING deployment.
# It keeps the same DSEQ and ingress URL - NO DNS changes required.
# Use this for code-only updates, env var changes, or image tag updates.
#
# For changes that require a full redeploy (CPU/RAM/storage changes),
# use the "Deploy to Akash Network (Full Redeploy)" workflow instead.

on:
  # Auto-trigger after successful Docker image build+push
  workflow_run:
    workflows: ["Build and Push Docker Image to GHCR"]
    types:
      - completed
    branches: [main]

  workflow_dispatch:
    inputs:
      service:
        description: 'Service to update'
        required: true
        type: choice
        options:
          - api        # Main API
          - auth       # Auth Service
          - gateway    # Gateway Service
          - infisical  # Secrets Manager
          - caddy      # Edge Proxy
      sdl_file:
        description: 'SDL file to deploy (relative to repo root)'
        required: true
        default: 'deploy-api.yaml'
        type: string
      use_infisical:
        description: 'Use Infisical for secrets management'
        required: false
        default: false
        type: boolean

concurrency:
  group: akash-manifest-update-${{ inputs.service }}
  cancel-in-progress: false

env:
  # Service DSEQ mapping — UPDATE THESE after full redeploy!
  # After redeploying via deploy-akash.yml, update with the new DSEQ from the output.
  DSEQ_api: "25460930"
  DSEQ_auth: "UPDATE_AFTER_REDEPLOY"
  DSEQ_gateway: "UPDATE_AFTER_REDEPLOY"
  DSEQ_infisical: "UPDATE_AFTER_REDEPLOY"
  DSEQ_caddy: "UPDATE_AFTER_REDEPLOY"

  # Provider mapping — UPDATE THESE after full redeploy!
  PROVIDER_api: "akash1v4mngfecem3xz0lqyr054na5g49andmyvnyykk"
  PROVIDER_auth: "UPDATE_AFTER_REDEPLOY"
  PROVIDER_gateway: "UPDATE_AFTER_REDEPLOY"
  PROVIDER_infisical: "UPDATE_AFTER_REDEPLOY"
  PROVIDER_caddy: "UPDATE_AFTER_REDEPLOY"

jobs:
  update-manifest:
    runs-on: ubuntu-latest
    environment: production
    # Skip if triggered by workflow_run and the build failed
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate DSEQ is configured
        run: |
          if [ "${{ env.DSEQ_api }}" == "UPDATE_AFTER_REDEPLOY" ]; then
            echo "::error::DSEQ values have not been updated after the full redeploy."
            echo "Update the env vars in this workflow file with the new DSEQs and providers."
            exit 1
          fi

      - name: Set deployment variables
        run: |
          # When auto-triggered by Docker build, default to 'api' service
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            SERVICE="api"
            SDL_FILE="deploy-api.yaml"
            echo "Auto-triggered by Docker build. Updating API manifest."
          else
            SERVICE="${{ inputs.service }}"
            SDL_FILE="${{ inputs.sdl_file }}"
          fi

          # Get DSEQ for selected service
          case "$SERVICE" in
            api)      DSEQ="${{ env.DSEQ_api }}"; PROVIDER="${{ env.PROVIDER_api }}" ;;
            auth)     DSEQ="${{ env.DSEQ_auth }}"; PROVIDER="${{ env.PROVIDER_auth }}" ;;
            gateway)  DSEQ="${{ env.DSEQ_gateway }}"; PROVIDER="${{ env.PROVIDER_gateway }}" ;;
            infisical) DSEQ="${{ env.DSEQ_infisical }}"; PROVIDER="${{ env.PROVIDER_infisical }}" ;;
            caddy)    DSEQ="${{ env.DSEQ_caddy }}"; PROVIDER="${{ env.PROVIDER_caddy }}" ;;
            *)        echo "Unknown service: $SERVICE"; exit 1 ;;
          esac

          echo "DSEQ=$DSEQ" >> $GITHUB_ENV
          echo "PROVIDER=$PROVIDER" >> $GITHUB_ENV
          echo "SERVICE=$SERVICE" >> $GITHUB_ENV
          echo "SDL_FILE=$SDL_FILE" >> $GITHUB_ENV

          echo "=== Manifest Update Configuration ==="
          echo "Service:  $SERVICE"
          echo "DSEQ:     $DSEQ"
          echo "Provider: $PROVIDER"
          echo "SDL File: $SDL_FILE"

      - name: Install Akash CLI and provider-services
        run: |
          # Install latest akash node CLI
          curl -sSfL https://raw.githubusercontent.com/akash-network/node/master/install.sh | sh -s -- -b /usr/local/bin
          akash version

          # Install latest provider-services CLI
          PROVIDER_VERSION=$(curl -s https://api.github.com/repos/akash-network/provider/releases/latest | jq -r '.tag_name')
          echo "Installing provider-services $PROVIDER_VERSION"
          curl -sSfL "https://github.com/akash-network/provider/releases/download/${PROVIDER_VERSION}/provider-services_linux_amd64.zip" -o /tmp/provider.zip
          unzip -o /tmp/provider.zip -d /usr/local/bin/
          chmod +x /usr/local/bin/provider-services
          provider-services version

      - name: Setup Akash wallet
        env:
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
          AKASH_MNEMONIC: ${{ secrets.AKASH_MNEMONIC }}
        run: |
          mkdir -p $HOME/.akash
          echo "$AKASH_MNEMONIC" | akash keys add $AKASH_KEY_NAME --recover --keyring-backend test --home $HOME/.akash
          AKASH_ADDRESS=$(akash keys show $AKASH_KEY_NAME -a --keyring-backend test --home $HOME/.akash)
          echo "AKASH_ADDRESS=$AKASH_ADDRESS" >> $GITHUB_ENV
          echo "Wallet address: $AKASH_ADDRESS"

      - name: Verify deployment exists
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
        run: |
          echo "Verifying deployment ${{ env.DSEQ }} exists and is active..."

          DEPLOYMENT_INFO=$(akash query deployment get \
            --owner ${{ env.AKASH_ADDRESS }} \
            --dseq ${{ env.DSEQ }} \
            --node $AKASH_NODE \
            --output json 2>/dev/null || echo '{}')

          STATE=$(echo "$DEPLOYMENT_INFO" | jq -r '.deployment.state // "unknown"')

          if [ "$STATE" != "active" ]; then
            echo "::error::Deployment ${{ env.DSEQ }} is not active (state: $STATE)"
            echo "Cannot send manifest to inactive deployment."
            echo "Use the full redeploy workflow instead."
            exit 1
          fi

          echo "Deployment is active. Ready to send manifest."

      - name: Setup certificates
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
        run: |
          echo "Generating and publishing fresh certificate..."

          akash tx cert generate client \
            --from deploy \
            --keyring-backend test \
            --home $HOME/.akash

          akash tx cert publish client \
            --from deploy \
            --keyring-backend test \
            --home $HOME/.akash \
            --node $AKASH_NODE \
            --chain-id $AKASH_CHAIN_ID \
            --gas-prices 0.025uakt \
            --gas auto \
            --gas-adjustment 1.5 \
            -y || echo "Certificate may already be published"

          sleep 10
          echo "Certificate setup complete"

      - name: Substitute secrets in SDL
        env:
          YUGABYTE_PASSWORD: ${{ secrets.YUGABYTE_PASSWORD }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          IPFS_API_URL: ${{ secrets.IPFS_API_URL }}
          OTEL_ENDPOINT: ${{ secrets.OTEL_ENDPOINT }}
          AKASH_CERT_JSON: ${{ secrets.AKASH_CERT_JSON }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          ARWEAVE_WALLET: ${{ secrets.ARWEAVE_WALLET }}
          FILECOIN_WALLET_KEY: ${{ secrets.FILECOIN_WALLET_KEY }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          AKASH_MNEMONIC: ${{ secrets.AKASH_MNEMONIC }}
          RPC_ENDPOINT: ${{ secrets.RPC_ENDPOINT }}
          GRPC_ENDPOINT: ${{ secrets.GRPC_ENDPOINT }}
          AKASH_MCP_PATH: ${{ secrets.AKASH_MCP_PATH }}
          INFISICAL_SERVICE_TOKEN: ${{ secrets.INFISICAL_SERVICE_TOKEN }}
          INFISICAL_PROJECT_ID: ${{ secrets.INFISICAL_PROJECT_ID }}
          INFISICAL_CLIENT_ID: ${{ secrets.INFISICAL_CLIENT_ID }}
          INFISICAL_CLIENT_SECRET: ${{ secrets.INFISICAL_CLIENT_SECRET }}
          USE_INFISICAL: ${{ inputs.use_infisical || 'false' }}
        run: |
          cp ${{ env.SDL_FILE }} deploy-final.yaml

          if [ "$USE_INFISICAL" == "true" ]; then
            echo "Using Infisical for secrets management"
            sed -i "s|PLACEHOLDER_INFISICAL_SERVICE_TOKEN|$INFISICAL_SERVICE_TOKEN|g" deploy-final.yaml
            sed -i "s|PLACEHOLDER_PROJECT_ID|$INFISICAL_PROJECT_ID|g" deploy-final.yaml
            sed -i "s|PLACEHOLDER_CLIENT_ID|$INFISICAL_CLIENT_ID|g" deploy-final.yaml
            sed -i "s|PLACEHOLDER_CLIENT_SECRET|$INFISICAL_CLIENT_SECRET|g" deploy-final.yaml
          else
            echo "Using direct secrets substitution"
            # Substitute secrets directly (supports multiple SDL variants)

            # Yugabyte (legacy) password placeholder
            if grep -q "your_secure_password_here_change_this" deploy-final.yaml; then
              if [ -z "$YUGABYTE_PASSWORD" ]; then
                echo "::error::YUGABYTE_PASSWORD is required for this SDL (legacy Yugabyte stack)."
                exit 1
              fi
              sed -i "s|your_secure_password_here_change_this|$YUGABYTE_PASSWORD|g" deploy-final.yaml
            fi

            # Postgres (current) connection placeholders
            if grep -q "__DATABASE_URL__" deploy-final.yaml; then
              if [ -z "$DATABASE_URL" ]; then
                echo "::error::DATABASE_URL is required for this SDL."
                exit 1
              fi
              sed -i "s|__DATABASE_URL__|$DATABASE_URL|g" deploy-final.yaml
            fi
            if grep -q "__IPFS_API_URL__" deploy-final.yaml; then
              if [ -z "$IPFS_API_URL" ]; then
                echo "::error::IPFS_API_URL is required for this SDL."
                exit 1
              fi
              sed -i "s|__IPFS_API_URL__|$IPFS_API_URL|g" deploy-final.yaml
            fi
            # Optional (leave blank if unused)
            sed -i "s|__OTEL_ENDPOINT__|${OTEL_ENDPOINT:-}|g" deploy-final.yaml
            sed -i "s|__AKASH_CERT_JSON__|${AKASH_CERT_JSON:-}|g" deploy-final.yaml

            sed -i "s|your_jwt_secret_min_32_chars_please_change_this_in_production|$JWT_SECRET|g" deploy-final.yaml
            sed -i "s|your_resend_api_key|${RESEND_API_KEY:-placeholder}|g" deploy-final.yaml
            sed -i "s|your_arweave_wallet|${ARWEAVE_WALLET:-placeholder}|g" deploy-final.yaml
            sed -i "s|your_filecoin_wallet_key|${FILECOIN_WALLET_KEY:-placeholder}|g" deploy-final.yaml
            sed -i "s|your_sentry_dsn|${SENTRY_DSN:-placeholder}|g" deploy-final.yaml
            sed -i "s|__AKASH_MNEMONIC__|${AKASH_MNEMONIC:-placeholder}|g" deploy-final.yaml
            sed -i "s|__RPC_ENDPOINT__|${RPC_ENDPOINT:-https://rpc.akashnet.net:443}|g" deploy-final.yaml
            sed -i "s|__GRPC_ENDPOINT__|${GRPC_ENDPOINT:-https://akash-grpc.publicnode.com:443}|g" deploy-final.yaml
            sed -i "s|__AKASH_MCP_PATH__|${AKASH_MCP_PATH:-/app/akash-mcp/dist/index.js}|g" deploy-final.yaml
          fi

          echo "SDL prepared with secrets"

      - name: Update deployment on-chain
        continue-on-error: true
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
        run: |
          echo "=== Updating Deployment On-Chain ==="
          echo "DSEQ: ${{ env.DSEQ }}"
          echo "This updates the on-chain version hash to match the new SDL."

          akash tx deployment update deploy-final.yaml \
            --dseq ${{ env.DSEQ }} \
            --from $AKASH_KEY_NAME \
            --keyring-backend test \
            --home $HOME/.akash \
            --node $AKASH_NODE \
            --chain-id $AKASH_CHAIN_ID \
            --gas-prices 0.025uakt \
            --gas auto \
            --gas-adjustment 1.5 \
            -y

          sleep 10
          echo "Deployment updated on-chain"

      - name: Send manifest to provider
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
          AKASH_FROM: deploy
        run: |
          echo "=== Sending Manifest Update ==="
          echo "DSEQ:     ${{ env.DSEQ }}"
          echo "Provider: ${{ env.PROVIDER }}"
          echo ""

          provider-services send-manifest deploy-final.yaml \
            --dseq ${{ env.DSEQ }} \
            --provider ${{ env.PROVIDER }} \
            --from $AKASH_KEY_NAME \
            --keyring-backend test \
            --home $HOME/.akash

          echo ""
          echo "Manifest sent successfully!"

      - name: Wait for update to propagate
        run: |
          echo "Waiting 30 seconds for container update..."
          sleep 30

      - name: Health check
        continue-on-error: true
        run: |
          SERVICE="${{ env.SERVICE }}"

          case "$SERVICE" in
            api)
              echo "Checking API health..."
              curl -sf --max-time 30 https://api.alternatefutures.ai/health || echo "Health check failed or timed out"
              ;;
            auth)
              echo "Checking Auth API health..."
              curl -sf --max-time 30 https://auth.alternatefutures.ai/health || echo "Health check failed or timed out"
              ;;
            *)
              echo "No health check configured for service: $SERVICE"
              ;;
          esac

      # ─── Database Schema Safety Check ──────────────────────────────────────────
      # The cloud API and auth service share the same PostgreSQL database but have
      # separate Prisma schemas. Container restarts MUST NOT use 'prisma db push'
      # (which drops tables not in its schema). This step verifies auth tables
      # survived the restart and re-seeds subscription plans if they're missing.
      # See: INCIDENTS.md (canonical runbook) for shared-DB safety rules and recovery steps.
      - name: Setup Node.js for DB verification
        if: env.SERVICE == 'api'
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Verify shared database integrity
        if: env.SERVICE == 'api'
        env:
          DATABASE_URL: ${{ secrets.AUTH_DATABASE_URL }}
        run: |
          echo "=== Shared Database Integrity Check ==="
          echo "Verifying auth tables were not dropped by cloud API container restart..."

          # Install Prisma CLI (needed for db execute)
          npm install -g prisma tsx

          # Check for critical auth tables
          RESULT=$(DATABASE_URL="$DATABASE_URL" npx prisma db execute \
            --stdin --schema service-cloud-api/prisma/schema.prisma 2>&1 <<< \
            "SELECT COUNT(*) as cnt FROM information_schema.tables WHERE table_schema = 'public' AND table_name LIKE 'auth_%';" \
            || echo "QUERY_FAILED")

          if echo "$RESULT" | grep -q "QUERY_FAILED"; then
            echo "::warning::Could not verify auth tables. Manual verification recommended."
          else
            echo "Auth table check passed."
          fi

          # Verify subscription plans exist (needed for user registration)
          PLANS_CHECK=$(DATABASE_URL="$DATABASE_URL" npx prisma db execute \
            --stdin --schema service-cloud-api/prisma/schema.prisma 2>&1 <<< \
            "SELECT name FROM auth_subscription_plans ORDER BY name;" \
            || echo "PLANS_MISSING")

          if echo "$PLANS_CHECK" | grep -q "PLANS_MISSING\|does not exist"; then
            echo "::error::Auth subscription_plans table is missing! Database may have been wiped."
            echo "Run the auth schema restore and seed script manually."
            echo "See INCIDENTS.md (canonical runbook) for instructions."
          else
            echo "Subscription plans table exists."
          fi

      - name: Update summary
        if: always()
        run: |
          echo "## Manifest Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Service** | ${{ env.SERVICE }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **DSEQ** | ${{ env.DSEQ }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Provider** | ${{ env.PROVIDER }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **SDL File** | ${{ env.SDL_FILE }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### What This Means" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Same DSEQ:** The deployment ID has not changed" >> $GITHUB_STEP_SUMMARY
          echo "- **Same Ingress URL:** No DNS update required" >> $GITHUB_STEP_SUMMARY
          echo "- **Container Restarted:** The service is now running the updated configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "If you need to change CPU, RAM, or storage resources, use the **Full Redeploy** workflow instead." >> $GITHUB_STEP_SUMMARY
