name: Deploy to Akash Network

on:
  # Automatically deploy to mainnet when pushing to main branch
  push:
    branches:
      - main
    # Deploy on any change to main (not just SDL/workflow changes)
    # This ensures every merge triggers a deployment

  # Manual deployment trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      sdl_file:
        description: 'SDL file to deploy'
        required: true
        default: 'deploy-mainnet.yaml'
        type: string

# Prevent multiple deployments from running simultaneously
# Cancel in-progress runs when a new deployment is triggered
concurrency:
  group: akash-production-deployment
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Use production environment for main branch, or user-selected for manual dispatch
    environment: ${{ github.event_name == 'push' && 'production' || inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Akash CLI
        run: |
          cd /tmp
          curl -sfL "https://github.com/akash-network/node/releases/download/v1.0.2/akash_1.0.2_linux_amd64.zip" -o akash.zip
          unzip akash.zip
          sudo mv akash /usr/local/bin/
          chmod +x /usr/local/bin/akash
          akash version

      - name: Setup Akash wallet
        env:
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
          AKASH_MNEMONIC: ${{ secrets.AKASH_MNEMONIC }}
        run: |
          echo "$AKASH_MNEMONIC" | akash keys add $AKASH_KEY_NAME --recover --keyring-backend test
          AKASH_ADDRESS=$(akash keys show $AKASH_KEY_NAME -a --keyring-backend test)
          echo "AKASH_ADDRESS=$AKASH_ADDRESS" >> $GITHUB_ENV
          echo "Wallet address: $AKASH_ADDRESS"

      - name: Check wallet balance
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
        run: |
          akash query bank balances ${{ env.AKASH_ADDRESS }} --node $AKASH_NODE

      - name: Substitute secrets in SDL
        env:
          YUGABYTE_PASSWORD: ${{ secrets.YUGABYTE_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          ARWEAVE_WALLET: ${{ secrets.ARWEAVE_WALLET }}
          FILECOIN_WALLET_KEY: ${{ secrets.FILECOIN_WALLET_KEY }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          SDL_FILE: ${{ github.event_name == 'push' && 'deploy-mainnet.yaml' || inputs.sdl_file }}
        run: |
          cp $SDL_FILE deploy-final.yaml

          # Substitute secrets
          sed -i "s|your_secure_password_here_change_this|$YUGABYTE_PASSWORD|g" deploy-final.yaml
          sed -i "s|your_jwt_secret_min_32_chars_please_change_this_in_production|$JWT_SECRET|g" deploy-final.yaml
          sed -i "s|your_resend_api_key|${RESEND_API_KEY:-placeholder}|g" deploy-final.yaml
          sed -i "s|your_arweave_wallet|${ARWEAVE_WALLET:-placeholder}|g" deploy-final.yaml
          sed -i "s|your_filecoin_wallet_key|${FILECOIN_WALLET_KEY:-placeholder}|g" deploy-final.yaml
          sed -i "s|your_sentry_dsn|${SENTRY_DSN:-placeholder}|g" deploy-final.yaml

          echo "SDL prepared with secrets"

      - name: Generate and publish certificate
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
        run: |
          # Always generate certificate locally (GitHub Actions runners are ephemeral)
          echo "Generating certificate locally..."
          akash tx cert generate client --from $AKASH_KEY_NAME --keyring-backend test

          # Always publish the certificate to ensure local cert matches blockchain
          # This replaces any existing certificate
          echo "Publishing certificate to blockchain..."
          akash tx cert publish client \
            --from $AKASH_KEY_NAME \
            --keyring-backend test \
            --node $AKASH_NODE \
            --chain-id $AKASH_CHAIN_ID \
            --gas-prices 0.025uakt \
            --gas auto \
            --gas-adjustment 1.5 \
            -y

          echo "Waiting for certificate to be committed..."
          sleep 15

          # Verify certificate exists on blockchain
          CERT_COUNT=$(akash query cert list --owner ${{ env.AKASH_ADDRESS }} --node $AKASH_NODE --output json | jq '.certificates | length')
          echo "Certificate count on blockchain: $CERT_COUNT"

      - name: Create deployment
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
          AKASH_GAS: auto
          AKASH_GAS_ADJUSTMENT: 1.5
          AKASH_GAS_PRICES: 0.025uakt
        run: |
          TX_OUTPUT=$(akash tx deployment create deploy-final.yaml \
            --from $AKASH_KEY_NAME \
            --keyring-backend test \
            --node $AKASH_NODE \
            --chain-id $AKASH_CHAIN_ID \
            --gas $AKASH_GAS \
            --gas-adjustment $AKASH_GAS_ADJUSTMENT \
            --gas-prices $AKASH_GAS_PRICES \
            -y \
            --output json)

          echo "$TX_OUTPUT"
          TX_HASH=$(echo "$TX_OUTPUT" | jq -r '.txhash')
          echo "DEPLOYMENT_TX=$TX_HASH" >> $GITHUB_ENV
          echo "Deployment transaction: $TX_HASH"

          # Wait for transaction to be committed and indexed
          echo "Waiting for transaction to be committed..."
          sleep 15

      - name: Get deployment DSEQ
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
        run: |
          # Query the transaction to get the DSEQ from events
          echo "Querying transaction ${{ env.DEPLOYMENT_TX }} for DSEQ..."
          TX_RESULT=$(akash query tx ${{ env.DEPLOYMENT_TX }} --node $AKASH_NODE --chain-id $AKASH_CHAIN_ID --output json)

          # Extract DSEQ from EventDeploymentCreated event
          # The DSEQ is in a JSON string inside the 'id' attribute value
          DSEQ=$(echo "$TX_RESULT" | jq -r '
            .events[]?
            | select(.type=="akash.deployment.v1.EventDeploymentCreated")
            | .attributes[]?
            | select(.key=="id")
            | .value
            | fromjson
            | .dseq
          ' 2>/dev/null || echo "")

          # Fallback: Try the market event which also has dseq
          if [ -z "$DSEQ" ] || [ "$DSEQ" == "null" ]; then
            echo "Trying EventOrderCreated..."
            DSEQ=$(echo "$TX_RESULT" | jq -r '
              .events[]?
              | select(.type=="akash.market.v1.EventOrderCreated")
              | .attributes[]?
              | select(.key=="id")
              | .value
              | fromjson
              | .dseq
            ' 2>/dev/null || echo "")
          fi

          # Fallback: Parse from tx body
          if [ -z "$DSEQ" ] || [ "$DSEQ" == "null" ]; then
            echo "Trying transaction body..."
            DSEQ=$(echo "$TX_RESULT" | jq -r '.tx.body.messages[]? | select(."@type"=="/akash.deployment.v1beta4.MsgCreateDeployment") | .id.dseq' 2>/dev/null || echo "")
          fi

          # Final fallback: Query deployment list
          if [ -z "$DSEQ" ] || [ "$DSEQ" == "null" ]; then
            echo "Transaction parsing failed, querying deployment list..."
            sleep 10
            DSEQ=$(akash query deployment list --owner ${{ env.AKASH_ADDRESS }} --node $AKASH_NODE --output json | jq -r '.deployments[]?.deployment?.deployment_id?.dseq' 2>/dev/null | head -n1 || echo "")
          fi

          # Validate DSEQ
          if [ -z "$DSEQ" ] || [ "$DSEQ" == "null" ]; then
            echo "Error: Could not extract DSEQ from transaction or deployment list"
            echo "Full transaction result:"
            echo "$TX_RESULT" | jq '.'
            echo ""
            echo "Deployment list:"
            akash query deployment list --owner ${{ env.AKASH_ADDRESS }} --node $AKASH_NODE --output json | jq '.'
            exit 1
          fi

          echo "DSEQ=$DSEQ" >> $GITHUB_ENV
          echo "Deployment DSEQ: $DSEQ"

      - name: Wait for bids
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
        run: |
          echo "Waiting for provider bids (max 5 minutes)..."
          for i in {1..30}; do
            BID_COUNT=$(akash query market bid list --owner ${{ env.AKASH_ADDRESS }} --dseq ${{ env.DSEQ }} --node $AKASH_NODE --output json | jq '.bids | length')
            echo "Attempt $i/30: $BID_COUNT bids received"

            if [ "$BID_COUNT" -gt "0" ]; then
              echo "Bids received!"
              break
            fi

            sleep 10
          done

      - name: List and accept best bid
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
        run: |
          # Get all bids
          BIDS=$(akash query market bid list --owner ${{ env.AKASH_ADDRESS }} --dseq ${{ env.DSEQ }} --node $AKASH_NODE --output json)

          echo "=== Debug: Full bid structure ==="
          echo "$BIDS" | jq '.bids[0]' || echo "No bids found"

          echo ""
          echo "=== Bid summary ==="
          # Show provider and price from each bid
          echo "$BIDS" | jq -r '.bids[] | "\(.bid.id.provider) - \(.bid.price.amount) uakt"'

          # Find the lowest bid and extract provider
          # Sort by price and get the first (lowest) bid
          LOWEST_BID=$(echo "$BIDS" | jq '.bids | sort_by(.bid.price.amount | tonumber) | .[0]')

          # Extract provider from correct path: .bid.id.provider
          PROVIDER=$(echo "$LOWEST_BID" | jq -r '.bid.id.provider')

          if [ -z "$PROVIDER" ]; then
            echo "Error: Could not extract provider address"
            echo "Lowest bid structure:"
            echo "$LOWEST_BID" | jq '.'
            exit 1
          fi

          PRICE=$(echo "$LOWEST_BID" | jq -r '.bid.price.amount')
          echo "Accepting bid from provider: $PROVIDER (Price: $PRICE uakt)"

          akash tx market lease create \
            --dseq ${{ env.DSEQ }} \
            --provider $PROVIDER \
            --from $AKASH_KEY_NAME \
            --keyring-backend test \
            --node $AKASH_NODE \
            --chain-id $AKASH_CHAIN_ID \
            --gas auto \
            --gas-adjustment 1.5 \
            --gas-prices 0.025uakt \
            -y

      - name: Get lease status and service URIs
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
        run: |
          sleep 20
          echo "=== Lease Status ==="
          akash query market lease list --owner ${{ env.AKASH_ADDRESS }} --dseq ${{ env.DSEQ }} --node $AKASH_NODE

          echo ""
          echo "=== Service URIs ==="
          PROVIDER=$(akash query market lease list --owner ${{ env.AKASH_ADDRESS }} --dseq ${{ env.DSEQ }} --node $AKASH_NODE --output json | jq -r '.leases[0].lease.lease_id.provider')
          echo "PROVIDER=$PROVIDER" >> $GITHUB_ENV
          echo "Provider: $PROVIDER"

          # Get provider info to find their API endpoint
          echo ""
          echo "Querying provider host..."
          PROVIDER_INFO=$(akash query provider get $PROVIDER --node $AKASH_NODE --output json)
          PROVIDER_HOST=$(echo "$PROVIDER_INFO" | jq -r '.provider.host_uri')
          echo "Provider Host: $PROVIDER_HOST"

          # Query lease status from provider API using curl
          echo ""
          echo "Fetching service URIs from provider..."
          CERT_PATH="$HOME/.akash/certs"

          # Try to get lease status via provider API
          LEASE_STATUS=$(curl -sk \
            --cert "$CERT_PATH/client.crt" \
            --key "$CERT_PATH/client.key" \
            "https://$PROVIDER_HOST:8443/lease/${{ env.DSEQ }}/1/1/status" 2>/dev/null || echo "")

          if [ -n "$LEASE_STATUS" ]; then
            echo "$LEASE_STATUS" | jq '.'

            # Extract and display service URIs
            echo ""
            echo "=== Service Endpoints ==="
            echo "$LEASE_STATUS" | jq -r '.services // {} | to_entries[] | "Service: \(.key)\n  URIs: \(.value.uris // [])\n"'
            echo "$LEASE_STATUS" | jq -r '.forwarded_ports // {} | to_entries[] | "Service: \(.key)\n  Host: \(.value[0].host // "N/A")\n  Port: \(.value[0].port // "N/A")\n  External Port: \(.value[0].externalPort // "N/A")\n"'
          else
            echo "Note: Could not fetch lease status from provider API"
            echo "This is expected if certificate authentication is not set up"
            echo ""
            echo "Service endpoints will be available once the deployment is fully active."
            echo "You can check the provider's status page or use 'akash query' commands to get service information."
          fi

      - name: Setup Node.js for DNS sync
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies for DNS sync
        run: |
          npm install -g tsx
          npm install

      - name: Sync DNS records
        continue-on-error: true
        env:
          OPENPROVIDER_USERNAME: ${{ secrets.OPENPROVIDER_USERNAME }}
          OPENPROVIDER_PASSWORD: ${{ secrets.OPENPROVIDER_PASSWORD }}
          DOMAIN: alternatefutures.ai
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
        run: |
          echo "Syncing DNS for deployment ${{ env.DSEQ }} on provider ${{ env.PROVIDER }}"
          if [ -z "${{ env.PROVIDER }}" ] || [ "${{ env.PROVIDER }}" == "null" ]; then
            echo "Warning: Provider address not available, skipping DNS sync"
            echo "You can manually configure DNS using the deployment info from the logs above"
            exit 0
          fi
          tsx scripts/sync-dns.ts ${{ env.DSEQ }} ${{ env.PROVIDER }}

      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ github.event_name == 'push' && 'production' || inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SDL File**: ${{ github.event_name == 'push' && 'deploy-mainnet.yaml' || inputs.sdl_file }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Wallet**: ${{ env.AKASH_ADDRESS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **DSEQ**: ${{ env.DSEQ }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Provider**: ${{ env.PROVIDER }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Transaction**: ${{ env.DEPLOYMENT_TX }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### DNS Records (Auto-configured)" >> $GITHUB_STEP_SUMMARY
          echo "- **api.alternatefutures.ai** → GraphQL API" >> $GITHUB_STEP_SUMMARY
          echo "- **yb.alternatefutures.ai** → YugabyteDB Admin UI" >> $GITHUB_STEP_SUMMARY
          echo "- **ipfs.alternatefutures.ai** → IPFS Gateway" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Wait for DNS propagation (2-5 minutes)" >> $GITHUB_STEP_SUMMARY
          echo "2. Monitor deployment health" >> $GITHUB_STEP_SUMMARY
          echo "3. Check service logs" >> $GITHUB_STEP_SUMMARY
          echo "4. Test endpoints once DNS propagates" >> $GITHUB_STEP_SUMMARY
