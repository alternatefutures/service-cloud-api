name: Deploy to Akash Network (Full Redeploy)
permissions:
  contents: read
  pull-requests: write

# IMPORTANT: This workflow creates a NEW deployment with a NEW DSEQ.
# This means DNS records will need to be updated after deployment.
# For code-only updates that keep the same DSEQ, use the "Update Manifest" workflow instead.

on:
  # Manual deployment only - no automatic deployment on push
  # This prevents accidental redeployments that require DNS changes
  workflow_dispatch:
    inputs:
      deployment_type:
        description: 'Deployment type (full-redeploy creates new DSEQ, requires DNS update)'
        required: true
        default: 'full-redeploy'
        type: choice
        options:
          - full-redeploy
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      sdl_file:
        description: 'SDL file to deploy'
        required: true
        default: 'deploy-api.yaml'
        type: choice
        options:
          - deploy-api.yaml
          - deploy-mainnet-with-infisical.yaml
      use_infisical:
        description: 'Use Infisical for secrets management'
        required: false
        default: false
        type: boolean
      confirm_dns_update:
        description: 'I understand this creates a new DSEQ and requires DNS update'
        required: true
        default: false
        type: boolean

# Prevent multiple deployments from running simultaneously
# Cancel in-progress runs when a new deployment is triggered
concurrency:
  group: akash-production-deployment
  cancel-in-progress: true

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Validate DNS update confirmation
        if: ${{ inputs.confirm_dns_update != true }}
        run: |
          echo "::error::You must confirm you understand this creates a new DSEQ and requires DNS update"
          echo ""
          echo "This workflow creates a FULL REDEPLOY with a new DSEQ."
          echo "After deployment, you will need to update DNS records."
          echo ""
          echo "For code-only updates that keep the same DSEQ and ingress URL,"
          echo "use the 'Update Manifest (No Redeploy)' workflow instead."
          exit 1

  deploy:
    needs: validate
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Akash CLI
        run: |
          cd /tmp
          curl -sfL "https://github.com/akash-network/node/releases/download/v1.0.2/akash_1.0.2_linux_amd64.zip" -o akash.zip
          unzip akash.zip
          sudo mv akash /usr/local/bin/
          chmod +x /usr/local/bin/akash
          akash version

      - name: Setup Akash wallet
        env:
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
          AKASH_MNEMONIC: ${{ secrets.AKASH_MNEMONIC }}
        run: |
          echo "$AKASH_MNEMONIC" | akash keys add $AKASH_KEY_NAME --recover --keyring-backend test
          AKASH_ADDRESS=$(akash keys show $AKASH_KEY_NAME -a --keyring-backend test)
          echo "AKASH_ADDRESS=$AKASH_ADDRESS" >> $GITHUB_ENV
          echo "Wallet address: $AKASH_ADDRESS"

      - name: Check wallet balance
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
        run: |
          akash query bank balances ${{ env.AKASH_ADDRESS }} --node $AKASH_NODE

      - name: Substitute secrets in SDL
        env:
          YUGABYTE_PASSWORD: ${{ secrets.YUGABYTE_PASSWORD }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          IPFS_API_URL: ${{ secrets.IPFS_API_URL }}
          OTEL_ENDPOINT: ${{ secrets.OTEL_ENDPOINT }}
          AKASH_CERT_JSON: ${{ secrets.AKASH_CERT_JSON }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
          ARWEAVE_WALLET: ${{ secrets.ARWEAVE_WALLET }}
          FILECOIN_WALLET_KEY: ${{ secrets.FILECOIN_WALLET_KEY }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          AKASH_MNEMONIC: ${{ secrets.AKASH_MNEMONIC }}
          RPC_ENDPOINT: ${{ secrets.RPC_ENDPOINT }}
          GRPC_ENDPOINT: ${{ secrets.GRPC_ENDPOINT }}
          AKASH_MCP_PATH: ${{ secrets.AKASH_MCP_PATH }}
          INFISICAL_SERVICE_TOKEN: ${{ secrets.INFISICAL_SERVICE_TOKEN }}
          INFISICAL_PROJECT_ID: ${{ secrets.INFISICAL_PROJECT_ID }}
          INFISICAL_CLIENT_ID: ${{ secrets.INFISICAL_CLIENT_ID }}
          INFISICAL_CLIENT_SECRET: ${{ secrets.INFISICAL_CLIENT_SECRET }}
          SDL_FILE: ${{ inputs.sdl_file }}
          USE_INFISICAL: ${{ inputs.use_infisical || 'false' }}
        run: |
          cp $SDL_FILE deploy-final.yaml

          if [ "$USE_INFISICAL" == "true" ] || [ "$SDL_FILE" == "deploy-mainnet-with-infisical.yaml" ]; then
            echo "Using Infisical for secrets management"
            # Substitute Infisical tokens
            sed -i "s|PLACEHOLDER_INFISICAL_SERVICE_TOKEN|$INFISICAL_SERVICE_TOKEN|g" deploy-final.yaml
            sed -i "s|PLACEHOLDER_PROJECT_ID|$INFISICAL_PROJECT_ID|g" deploy-final.yaml
            sed -i "s|PLACEHOLDER_CLIENT_ID|$INFISICAL_CLIENT_ID|g" deploy-final.yaml
            sed -i "s|PLACEHOLDER_CLIENT_SECRET|$INFISICAL_CLIENT_SECRET|g" deploy-final.yaml
          else
            echo "Using direct secrets substitution"
            # Substitute secrets directly (supports multiple SDL variants)

            # Yugabyte (legacy) password placeholder
            if grep -q "your_secure_password_here_change_this" deploy-final.yaml; then
              if [ -z "$YUGABYTE_PASSWORD" ]; then
                echo "::error::YUGABYTE_PASSWORD is required for this SDL (legacy Yugabyte stack)."
                exit 1
              fi
              sed -i "s|your_secure_password_here_change_this|$YUGABYTE_PASSWORD|g" deploy-final.yaml
            fi

            # Postgres (current) connection placeholders
            if grep -q "__DATABASE_URL__" deploy-final.yaml; then
              if [ -z "$DATABASE_URL" ]; then
                echo "::error::DATABASE_URL is required for this SDL."
                exit 1
              fi
              sed -i "s|__DATABASE_URL__|$DATABASE_URL|g" deploy-final.yaml
            fi
            if grep -q "__IPFS_API_URL__" deploy-final.yaml; then
              if [ -z "$IPFS_API_URL" ]; then
                echo "::error::IPFS_API_URL is required for this SDL."
                exit 1
              fi
              sed -i "s|__IPFS_API_URL__|$IPFS_API_URL|g" deploy-final.yaml
            fi
            # Optional (leave blank if unused)
            sed -i "s|__OTEL_ENDPOINT__|${OTEL_ENDPOINT:-}|g" deploy-final.yaml
            sed -i "s|__AKASH_CERT_JSON__|${AKASH_CERT_JSON:-}|g" deploy-final.yaml

            sed -i "s|your_jwt_secret_min_32_chars_please_change_this_in_production|$JWT_SECRET|g" deploy-final.yaml
            sed -i "s|your_resend_api_key|${RESEND_API_KEY:-placeholder}|g" deploy-final.yaml
            sed -i "s|your_arweave_wallet|${ARWEAVE_WALLET:-placeholder}|g" deploy-final.yaml
            sed -i "s|your_filecoin_wallet_key|${FILECOIN_WALLET_KEY:-placeholder}|g" deploy-final.yaml
            sed -i "s|your_sentry_dsn|${SENTRY_DSN:-placeholder}|g" deploy-final.yaml
            sed -i "s|__AKASH_MNEMONIC__|${AKASH_MNEMONIC:-placeholder}|g" deploy-final.yaml
            sed -i "s|__RPC_ENDPOINT__|${RPC_ENDPOINT:-https://rpc.akashnet.net:443}|g" deploy-final.yaml
            sed -i "s|__GRPC_ENDPOINT__|${GRPC_ENDPOINT:-https://akash-grpc.publicnode.com:443}|g" deploy-final.yaml
            sed -i "s|__AKASH_MCP_PATH__|${AKASH_MCP_PATH:-/app/akash-mcp/dist/index.js}|g" deploy-final.yaml
          fi

          echo "âœ… SDL prepared with secrets"

      - name: Setup certificates
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
          AKASH_CLIENT_CRT: ${{ secrets.AKASH_CLIENT_CRT }}
          AKASH_CLIENT_KEY: ${{ secrets.AKASH_CLIENT_KEY }}
        run: |
          CERT_PATH="$HOME/.akash/certs"
          mkdir -p "$CERT_PATH"

          # Check if certificates are stored in secrets
          if [ -n "$AKASH_CLIENT_CRT" ] && [ -n "$AKASH_CLIENT_KEY" ]; then
            echo "Restoring certificates from GitHub Secrets..."
            echo "$AKASH_CLIENT_CRT" | base64 -d > "$CERT_PATH/client.crt"
            echo "$AKASH_CLIENT_KEY" | base64 -d > "$CERT_PATH/client.key"
            chmod 600 "$CERT_PATH/client.crt" "$CERT_PATH/client.key"
            echo "âœ“ Certificates restored"

            # Verify certificate exists on blockchain
            CERT_COUNT=$(akash query cert list --owner ${{ env.AKASH_ADDRESS }} --node $AKASH_NODE --output json | jq '.certificates | length')
            echo "Certificate count on blockchain: $CERT_COUNT"
          else
            echo "No certificates found in secrets. Generating new ones..."
            echo "âš ï¸  After this deployment, run the 'Setup Akash Certificates' workflow to store certificates as secrets"

            # Generate certificate locally
            echo "Generating certificate locally..."
            akash tx cert generate client --from $AKASH_KEY_NAME --keyring-backend test

            # Publish the certificate to blockchain
            echo "Publishing certificate to blockchain..."
            akash tx cert publish client \
              --from $AKASH_KEY_NAME \
              --keyring-backend test \
              --node $AKASH_NODE \
              --chain-id $AKASH_CHAIN_ID \
              --gas-prices 0.025uakt \
              --gas auto \
              --gas-adjustment 1.5 \
              -y

            echo "Waiting for certificate to be committed..."
            sleep 15

            # Verify certificate exists on blockchain
            CERT_COUNT=$(akash query cert list --owner ${{ env.AKASH_ADDRESS }} --node $AKASH_NODE --output json | jq '.certificates | length')
            echo "Certificate count on blockchain: $CERT_COUNT"
          fi

      - name: Create deployment
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
          AKASH_GAS: auto
          AKASH_GAS_ADJUSTMENT: 1.5
          AKASH_GAS_PRICES: 0.025uakt
        run: |
          TX_OUTPUT=$(akash tx deployment create deploy-final.yaml \
            --from $AKASH_KEY_NAME \
            --keyring-backend test \
            --node $AKASH_NODE \
            --chain-id $AKASH_CHAIN_ID \
            --gas $AKASH_GAS \
            --gas-adjustment $AKASH_GAS_ADJUSTMENT \
            --gas-prices $AKASH_GAS_PRICES \
            -y \
            --output json)

          echo "$TX_OUTPUT"
          TX_HASH=$(echo "$TX_OUTPUT" | jq -r '.txhash')
          echo "DEPLOYMENT_TX=$TX_HASH" >> $GITHUB_ENV
          echo "Deployment transaction: $TX_HASH"

          # Wait for transaction to be committed and indexed
          echo "Waiting for transaction to be committed..."
          sleep 15

      - name: Get deployment DSEQ
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
        run: |
          # Query the transaction to get the DSEQ from events
          echo "Querying transaction ${{ env.DEPLOYMENT_TX }} for DSEQ..."
          TX_RESULT=$(akash query tx ${{ env.DEPLOYMENT_TX }} --node $AKASH_NODE --chain-id $AKASH_CHAIN_ID --output json)

          # Extract DSEQ from EventDeploymentCreated event
          # The DSEQ is in a JSON string inside the 'id' attribute value
          DSEQ=$(echo "$TX_RESULT" | jq -r '
            .events[]?
            | select(.type=="akash.deployment.v1.EventDeploymentCreated")
            | .attributes[]?
            | select(.key=="id")
            | .value
            | fromjson
            | .dseq
          ' 2>/dev/null || echo "")

          # Fallback: Try the market event which also has dseq
          if [ -z "$DSEQ" ] || [ "$DSEQ" == "null" ]; then
            echo "Trying EventOrderCreated..."
            DSEQ=$(echo "$TX_RESULT" | jq -r '
              .events[]?
              | select(.type=="akash.market.v1.EventOrderCreated")
              | .attributes[]?
              | select(.key=="id")
              | .value
              | fromjson
              | .dseq
            ' 2>/dev/null || echo "")
          fi

          # Fallback: Parse from tx body
          if [ -z "$DSEQ" ] || [ "$DSEQ" == "null" ]; then
            echo "Trying transaction body..."
            DSEQ=$(echo "$TX_RESULT" | jq -r '.tx.body.messages[]? | select(."@type"=="/akash.deployment.v1beta4.MsgCreateDeployment") | .id.dseq' 2>/dev/null || echo "")
          fi

          # Final fallback: Query deployment list
          if [ -z "$DSEQ" ] || [ "$DSEQ" == "null" ]; then
            echo "Transaction parsing failed, querying deployment list..."
            sleep 10
            DSEQ=$(akash query deployment list --owner ${{ env.AKASH_ADDRESS }} --node $AKASH_NODE --output json | jq -r '.deployments[]?.deployment?.deployment_id?.dseq' 2>/dev/null | head -n1 || echo "")
          fi

          # Validate DSEQ
          if [ -z "$DSEQ" ] || [ "$DSEQ" == "null" ]; then
            echo "Error: Could not extract DSEQ from transaction or deployment list"
            echo "Full transaction result:"
            echo "$TX_RESULT" | jq '.'
            echo ""
            echo "Deployment list:"
            akash query deployment list --owner ${{ env.AKASH_ADDRESS }} --node $AKASH_NODE --output json | jq '.'
            exit 1
          fi

          echo "DSEQ=$DSEQ" >> $GITHUB_ENV
          echo "Deployment DSEQ: $DSEQ"

      - name: Wait for bids
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
        run: |
          echo "Waiting for provider bids (max 30 seconds - TEMPORARY)..."
          # TODO: Restore to 5 minutes for production (see Linear ticket)
          for i in {1..6}; do
            BID_COUNT=$(akash query market bid list --owner ${{ env.AKASH_ADDRESS }} --dseq ${{ env.DSEQ }} --node $AKASH_NODE --output json | jq '.bids | length')
            echo "Attempt $i/6: $BID_COUNT bids received"

            if [ "$BID_COUNT" -gt "0" ]; then
              echo "Bids received!"
              break
            fi

            sleep 5
          done

      - name: List and accept best bid (with uptime filter)
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
          MIN_UPTIME: 99.9
        run: |
          # Get all bids
          BIDS=$(akash query market bid list --owner ${{ env.AKASH_ADDRESS }} --dseq ${{ env.DSEQ }} --node $AKASH_NODE --output json)

          echo "=== Filtering bids by provider uptime (minimum: ${MIN_UPTIME}%) ==="

          # Get list of all providers from bids
          PROVIDERS=$(echo "$BIDS" | jq -r '.bids[].bid.id.provider')

          # Create a filtered bids array
          FILTERED_BIDS="[]"

          # Blocked providers (broken hostnames, NAT hairpin, known bad)
          BLOCKED_PROVIDERS="akash1smapjx8m8363nmdvc2yr9atlqy8vcql73m9l0v"

          for PROVIDER_ADDR in $PROVIDERS; do
            echo "Checking provider: $PROVIDER_ADDR"

            # Skip blocked providers
            if echo "$BLOCKED_PROVIDERS" | grep -q "$PROVIDER_ADDR"; then
              echo "  âœ— BLOCKED provider - skipping"
              continue
            fi

            # Query provider attributes from Akash
            PROVIDER_INFO=$(akash query provider get "$PROVIDER_ADDR" --node $AKASH_NODE --output json 2>/dev/null || echo '{}')

            # Try to get uptime from provider attributes
            # Note: Akash providers may not expose uptime directly, so we'll use akashlytics.com API
            UPTIME=$(curl -s "https://api.akashlytics.com/v1/providers/$PROVIDER_ADDR" 2>/dev/null | jq -r '.uptime // null' || echo "null")

            if [ "$UPTIME" == "null" ] || [ -z "$UPTIME" ]; then
              echo "  âš ï¸  Uptime data not available for $PROVIDER_ADDR, including anyway"
              # If uptime data not available, include the provider (fail open)
              BID=$(echo "$BIDS" | jq ".bids[] | select(.bid.id.provider == \"$PROVIDER_ADDR\")")
              FILTERED_BIDS=$(echo "$FILTERED_BIDS" | jq ". + [$BID]")
            else
              # Convert uptime to comparable format (handle percentage)
              UPTIME_VALUE=$(echo "$UPTIME" | sed 's/%//')

              # Compare uptime (using bc for float comparison)
              if (( $(echo "$UPTIME_VALUE >= $MIN_UPTIME" | bc -l) )); then
                echo "  âœ“ Uptime: ${UPTIME_VALUE}% (passes ${MIN_UPTIME}% threshold)"
                BID=$(echo "$BIDS" | jq ".bids[] | select(.bid.id.provider == \"$PROVIDER_ADDR\")")
                FILTERED_BIDS=$(echo "$FILTERED_BIDS" | jq ". + [$BID]")
              else
                echo "  âœ— Uptime: ${UPTIME_VALUE}% (below ${MIN_UPTIME}% threshold) - SKIPPED"
              fi
            fi
          done

          echo ""
          echo "=== Filtered bids (uptime â‰¥ ${MIN_UPTIME}%) ==="
          BID_COUNT=$(echo "$FILTERED_BIDS" | jq 'length')
          echo "Qualified providers: $BID_COUNT"

          if [ "$BID_COUNT" -eq "0" ]; then
            echo "Error: No providers meet the uptime requirement of ${MIN_UPTIME}%"
            echo "Consider lowering MIN_UPTIME or waiting for more bids"
            exit 1
          fi

          echo "$FILTERED_BIDS" | jq -r '.[] | "\(.bid.id.provider) - \(.bid.price.amount) uakt"'

          # Select lowest price bid from filtered results
          LOWEST_BID=$(echo "$FILTERED_BIDS" | jq 'sort_by(.bid.price.amount | tonumber) | .[0]')
          PROVIDER=$(echo "$LOWEST_BID" | jq -r '.bid.id.provider')

          if [ -z "$PROVIDER" ]; then
            echo "Error: Could not extract provider address from filtered bids"
            echo "Lowest bid structure:"
            echo "$LOWEST_BID" | jq '.'
            exit 1
          fi

          PRICE=$(echo "$LOWEST_BID" | jq -r '.bid.price.amount')

          echo ""
          echo "Accepting bid from provider: $PROVIDER (Price: $PRICE uakt)"
          echo "PROVIDER=$PROVIDER" >> $GITHUB_ENV

          akash tx market lease create \
            --dseq ${{ env.DSEQ }} \
            --provider $PROVIDER \
            --from $AKASH_KEY_NAME \
            --keyring-backend test \
            --node $AKASH_NODE \
            --chain-id $AKASH_CHAIN_ID \
            --gas auto \
            --gas-adjustment 1.5 \
            --gas-prices 0.025uakt \
            -y

      - name: Install provider-services CLI
        run: |
          PROVIDER_VERSION=$(curl -s https://api.github.com/repos/akash-network/provider/releases/latest | jq -r '.tag_name')
          echo "Installing provider-services $PROVIDER_VERSION"
          curl -sSfL "https://github.com/akash-network/provider/releases/download/${PROVIDER_VERSION}/provider-services_linux_amd64.zip" -o /tmp/provider.zip
          unzip -o /tmp/provider.zip -d /usr/local/bin/
          chmod +x /usr/local/bin/provider-services
          provider-services version

      - name: Send manifest to provider
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
        run: |
          echo "Sending manifest to provider ${{ env.PROVIDER }}..."
          sleep 10

          provider-services send-manifest deploy-final.yaml \
            --dseq ${{ env.DSEQ }} \
            --provider ${{ env.PROVIDER }} \
            --from $AKASH_KEY_NAME \
            --keyring-backend test \
            --node $AKASH_NODE \
            --home $HOME/.akash

          echo "Manifest sent successfully!"

      - name: Get lease status and service URIs
        env:
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_KEYRING_BACKEND: test
          AKASH_KEY_NAME: deploy
        run: |
          sleep 20
          echo "=== Lease Status ==="
          akash query market lease list --owner ${{ env.AKASH_ADDRESS }} --dseq ${{ env.DSEQ }} --node $AKASH_NODE

          echo ""
          echo "=== Service URIs ==="
          PROVIDER=$(akash query market lease list --owner ${{ env.AKASH_ADDRESS }} --dseq ${{ env.DSEQ }} --node $AKASH_NODE --output json | jq -r '.leases[0].lease.id.provider')
          echo "PROVIDER=$PROVIDER" >> $GITHUB_ENV
          echo "Provider: $PROVIDER"

          # Get provider info to find their API endpoint
          echo ""
          echo "Querying provider host..."
          PROVIDER_INFO=$(akash query provider get $PROVIDER --node $AKASH_NODE --output json)

          # Debug: Show provider info structure
          echo "Provider info:"
          echo "$PROVIDER_INFO" | jq '.'

          # Try different possible paths for host URI
          PROVIDER_HOST=$(echo "$PROVIDER_INFO" | jq -r '.provider.host_uri // .provider.hostUri // .host_uri // empty')

          if [ -z "$PROVIDER_HOST" ] || [ "$PROVIDER_HOST" == "null" ]; then
            echo "Could not extract provider host URI from provider info"
            echo "Available provider fields:"
            echo "$PROVIDER_INFO" | jq 'keys'
          else
            echo "Provider Host: $PROVIDER_HOST"
          fi

          # Query lease status from provider API using curl
          echo ""
          echo "Fetching service URIs from provider..."
          CERT_PATH="$HOME/.akash/certs"

          # Check if certificates exist
          echo "Checking for certificates..."
          if [ -d "$CERT_PATH" ]; then
            echo "Certificate directory exists"
            ls -la "$CERT_PATH"
          else
            echo "Certificate directory not found at $CERT_PATH"
          fi

          # Only try to query if we have both provider host and certificates
          if [ -n "$PROVIDER_HOST" ] && [ "$PROVIDER_HOST" != "null" ] && [ -f "$CERT_PATH/client.crt" ] && [ -f "$CERT_PATH/client.key" ]; then
            echo "Querying provider API at: https://$PROVIDER_HOST/lease/${{ env.DSEQ }}/1/1/status"

            # Try to get lease status via provider API with timeout
            LEASE_STATUS=$(curl -sk --max-time 10 \
              --cert "$CERT_PATH/client.crt" \
              --key "$CERT_PATH/client.key" \
              "https://$PROVIDER_HOST/lease/${{ env.DSEQ }}/1/1/status" 2>&1)

            CURL_EXIT=$?

            if [ $CURL_EXIT -eq 0 ] && [ -n "$LEASE_STATUS" ] && echo "$LEASE_STATUS" | jq -e '.' >/dev/null 2>&1; then
              echo "Successfully retrieved lease status!"
              echo "$LEASE_STATUS" | jq '.'

              # Extract and display service URIs
              echo ""
              echo "=== Service Endpoints ==="
              echo "$LEASE_STATUS" | jq -r '.services // {} | to_entries[] | "Service: \(.key)\n  URIs: \(.value.uris // [])\n"'
              echo "$LEASE_STATUS" | jq -r '.forwarded_ports // {} | to_entries[] | "Service: \(.key)\n  Host: \(.value[0].host // "N/A")\n  Port: \(.value[0].port // "N/A")\n  External Port: \(.value[0].externalPort // "N/A")\n"'
            else
              echo "Could not fetch lease status from provider API (exit code: $CURL_EXIT)"
              echo "Response: $LEASE_STATUS"
              echo ""
              echo "You can access the provider's web interface at: https://$PROVIDER_HOST"
              echo "Or check the lease status page: https://$PROVIDER_HOST/lease/${{ env.DSEQ }}/1/1/status"
            fi
          else
            echo "Skipping provider API query (missing certificates or provider host)"
            if [ -n "$PROVIDER_HOST" ] && [ "$PROVIDER_HOST" != "null" ]; then
              echo ""
              echo "Provider web interface: https://$PROVIDER_HOST"
              echo "Lease status (requires auth): https://$PROVIDER_HOST/lease/${{ env.DSEQ }}/1/1/status"
            fi
          fi

      - name: Setup Node.js for DNS sync and DB verification
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies for DNS sync and DB tools
        run: |
          npm install -g tsx prisma
          npm install

      # â”€â”€â”€ Database Schema Safety â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # After a full redeploy, the cloud API container's entrypoint runs prisma
      # migrate deploy. This step verifies that auth tables (from the separate
      # service-auth schema) still exist in the shared database, and re-pushes
      # + seeds them if they're missing. This prevents the auth service from
      # breaking due to missing tables after cloud API redeployment.
      # See: INCIDENTS.md (canonical runbook) for shared-DB safety rules and recovery steps.
      - name: Verify and restore auth schema if needed
        continue-on-error: true
        env:
          DATABASE_URL: ${{ secrets.AUTH_DATABASE_URL }}
        run: |
          echo "=== Shared Database Integrity Check ==="
          echo "Checking if auth tables exist after cloud API deployment..."

          # Check for auth tables by trying to query one
          AUTH_TABLES=$(psql "$DATABASE_URL" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public' AND table_name LIKE 'auth_%';" 2>/dev/null || echo "0")
          AUTH_TABLES=$(echo "$AUTH_TABLES" | tr -d ' ')

          if [ "$AUTH_TABLES" -lt "10" ] 2>/dev/null; then
            echo "::warning::Only $AUTH_TABLES auth tables found (expected ~20+). Auth schema may need restoration."
            echo "IMPORTANT: Run the following manually to restore auth schema:"
            echo "  cd service-auth"
            echo "  DATABASE_URL=<prod_url> npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > /tmp/auth.sql"
            echo "  DATABASE_URL=<prod_url> npx prisma db execute --stdin < /tmp/auth.sql"
            echo "  DATABASE_URL=<prod_url> npx tsx scripts/seed-plans.ts"
            echo ""
            echo "See INCIDENTS.md (canonical runbook) for detailed instructions."
          else
            echo "âœ“ Found $AUTH_TABLES auth tables â€” schema intact."
          fi

      - name: Sync DNS records
        continue-on-error: true
        env:
          OPENPROVIDER_USERNAME: ${{ secrets.OPENPROVIDER_USERNAME }}
          OPENPROVIDER_PASSWORD: ${{ secrets.OPENPROVIDER_PASSWORD }}
          DOMAIN: alternatefutures.ai
          AKASH_NODE: https://rpc.akashnet.net:443
          AKASH_CHAIN_ID: akashnet-2
        run: |
          echo "Syncing DNS for deployment ${{ env.DSEQ }} on provider ${{ env.PROVIDER }}"
          if [ -z "${{ env.PROVIDER }}" ] || [ "${{ env.PROVIDER }}" == "null" ]; then
            echo "Warning: Provider address not available, skipping DNS sync"
            echo "You can manually configure DNS using the deployment info from the logs above"
            exit 0
          fi
          tsx scripts/sync-dns.ts ${{ env.DSEQ }} ${{ env.PROVIDER }}

      - name: Post deployment URLs to PR
        if: false  # Disabled since this workflow is manual-only now
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get the PR number from the merge commit
          PR_NUMBER=$(gh pr list --state merged --base main --json number,mergeCommit \
            --jq ".[] | select(.mergeCommit.oid == \"${{ github.sha }}\") | .number" | head -n1)

          if [ -z "$PR_NUMBER" ]; then
            echo "No PR found for this merge commit, skipping PR comment"
            exit 0
          fi

          echo "Found PR #$PR_NUMBER for this deployment"

          # Create deployment URLs comment (using printf to avoid YAML parsing issues)
          printf -v COMMENT_BODY '%s\n' \
            '## ðŸš€ Deployment Successful' \
            '' \
            '**Deployment Details:**' \
            "- **DSEQ:** \`${{ env.DSEQ }}\`" \
            "- **Provider:** \`${{ env.PROVIDER }}\`" \
            "- **Transaction:** \`${{ env.DEPLOYMENT_TX }}\`" \
            '' \
            '**Service Endpoints:**' \
            '- ðŸŒ **API:** https://api.alternatefutures.ai' \
            '- ðŸ—„ï¸ **YugabyteDB Admin:** https://yb.alternatefutures.ai' \
            '- ðŸ“ **IPFS Gateway:** https://ipfs.alternatefutures.ai' \
            '' \
            '**Note:** DNS propagation may take 2-5 minutes. Services will be available once DNS resolves.' \
            '' \
            '---' \
            "*Deployed via Akash Network â€¢ [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"

          # Post comment to PR
          gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"

          echo "Posted deployment URLs to PR #$PR_NUMBER"

      - name: Deployment summary
        if: always()
        run: |
          # Console output for CLI/workflow logs
          echo ""
          echo "=========================================="
          echo "ðŸš€ DEPLOYMENT SUCCESSFUL"
          echo "=========================================="
          echo ""
          echo "Deployment Details:"
          echo "  Environment: ${{ inputs.environment }}"
          echo "  SDL File:    ${{ inputs.sdl_file }}"
          echo "  Trigger:     ${{ github.event_name }}"
          echo "  Branch:      ${{ github.ref_name }}"
          echo "  Wallet:      ${{ env.AKASH_ADDRESS }}"
          echo "  DSEQ:        ${{ env.DSEQ }}"
          echo "  Provider:    ${{ env.PROVIDER }}"
          echo "  Transaction: ${{ env.DEPLOYMENT_TX }}"
          echo ""
          echo "ðŸŒ Service Endpoints (Auto-configured DNS):"
          echo "  â€¢ https://api.alternatefutures.ai (GraphQL API)"
          echo "  â€¢ https://yb.alternatefutures.ai (YugabyteDB Admin)"
          echo "  â€¢ https://ipfs.alternatefutures.ai (IPFS Gateway)"
          echo ""
          echo "ðŸ“ Next Steps:"
          echo "  1. Wait for DNS propagation (2-5 minutes)"
          echo "  2. Monitor deployment health"
          echo "  3. Check service logs"
          echo "  4. Test endpoints once DNS propagates"
          echo ""
          echo "=========================================="
          echo ""

          # GitHub Actions summary for UI
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SDL File**: ${{ inputs.sdl_file }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Wallet**: ${{ env.AKASH_ADDRESS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **DSEQ**: ${{ env.DSEQ }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Provider**: ${{ env.PROVIDER }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Transaction**: ${{ env.DEPLOYMENT_TX }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŒ Service Endpoints (Auto-configured DNS)" >> $GITHUB_STEP_SUMMARY
          echo "- **API:** https://api.alternatefutures.ai" >> $GITHUB_STEP_SUMMARY
          echo "- **YugabyteDB Admin:** https://yb.alternatefutures.ai" >> $GITHUB_STEP_SUMMARY
          echo "- **IPFS Gateway:** https://ipfs.alternatefutures.ai" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Wait for DNS propagation (2-5 minutes)" >> $GITHUB_STEP_SUMMARY
          echo "2. Monitor deployment health" >> $GITHUB_STEP_SUMMARY
          echo "3. Check service logs" >> $GITHUB_STEP_SUMMARY
          echo "4. Test endpoints once DNS propagates" >> $GITHUB_STEP_SUMMARY
