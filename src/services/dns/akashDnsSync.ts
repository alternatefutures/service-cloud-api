/**
 * Akash DNS Synchronization
 * Automatically update DNS when Akash deployments change
 */

/* eslint-disable no-console */
import { exec } from 'child_process'
import { promisify } from 'util'
import * as https from 'https'
import * as fs from 'fs'
import * as path from 'path'
import * as os from 'os'
import { DNSManager } from './dnsManager.js'
import type {
  AkashDeployment,
  AkashService,
  DNSUpdateResult,
  OpenProviderConfig,
} from './types.js'

const execAsync = promisify(exec)

export class AkashDNSSync {
  private dnsManager: DNSManager
  private akashNode: string
  private akashChainId: string

  constructor(
    openProviderConfig: OpenProviderConfig,
    domain: string,
    akashNode: string,
    akashChainId: string
  ) {
    this.dnsManager = new DNSManager(openProviderConfig, domain)
    this.akashNode = akashNode
    this.akashChainId = akashChainId
  }

  /**
   * Get Akash deployment details including provider IPs
   */
  async getDeploymentDetails(
    dseq: string,
    provider: string
  ): Promise<AkashDeployment | null> {
    try {
      // Get provider info to determine service hostnames
      const { stdout: providerInfo } = await execAsync(
        `akash query provider get ${provider} --node ${this.akashNode} --chain-id ${this.akashChainId} --output json`
      )

      const providerData = JSON.parse(providerInfo)
      const providerUri =
        providerData.provider?.host_uri || providerData.host_uri

      if (!providerUri) {
        console.error('Provider URI not found in provider info')
        return null
      }

      console.log(`Provider: ${providerUri}`)

      // Try Cloudmos API first (no auth required)
      console.log('Trying Cloudmos API...')
      try {
        const cloudmosResponse = await globalThis.fetch(
          `https://api.cloudmos.io/v1/deployments/${dseq}`
        )

        if (cloudmosResponse.ok) {
          const cloudmosData = (await cloudmosResponse.json()) as {
            services?: Array<{ name: string; uris?: string[] }>
          }
          console.log('Got deployment info from Cloudmos')

          // Extract service URIs from Cloudmos data
          const services: AkashService[] = []
          if (cloudmosData.services) {
            for (const service of cloudmosData.services) {
              if (service.uris && service.uris.length > 0) {
                const uri = service.uris[0]
                const match = uri.match(/^(?:https?:\/\/)?([^:/]+):?(\d+)?/)
                if (match) {
                  services.push({
                    name: service.name,
                    externalIP: match[1],
                    port: match[2] ? parseInt(match[2]) : 80,
                    subdomain: '',
                  })
                }
              }
            }
          }

          if (services.length > 0) {
            return { dseq, provider, services }
          }
        }
      } catch {
        console.warn('Cloudmos API failed, falling back to provider query')
      }

      // Fallback: Query provider API (requires client certs)
      const leaseStatusPath = `/lease/${dseq}/1/1/status`

      // Check for Akash client certificates
      const akashDir = path.join(os.homedir(), '.akash')
      const certPath = path.join(akashDir, 'certs')
      const clientCert = path.join(certPath, 'client.crt')
      const clientKey = path.join(certPath, 'client.key')

      let cert: string | Buffer | undefined
      let key: string | Buffer | undefined

      // Try separate cert/key files first (restored from secrets - preferred)
      if (fs.existsSync(clientCert) && fs.existsSync(clientKey)) {
        console.log('Using Akash client certificates (separate files)')
        cert = fs.readFileSync(clientCert, 'utf-8')
        key = fs.readFileSync(clientKey, 'utf-8')
      } else {
        // Fallback: Try to find PEM file (generated by akash tx cert generate)
        const pemFiles = fs.existsSync(akashDir)
          ? fs.readdirSync(akashDir).filter(f => f.endsWith('.pem'))
          : []

        if (pemFiles.length > 0) {
          const pemPath = path.join(akashDir, pemFiles[0])
          console.log(`Using Akash client certificate (PEM): ${pemFiles[0]}`)
          console.log(
            'Note: If you see decryption errors, set AKASH_KEY_PASSPHRASE environment variable'
          )
          // Combined PEM file contains both cert and key
          const pemData = fs.readFileSync(pemPath, 'utf-8')

          // Extract certificate (between BEGIN CERTIFICATE and END CERTIFICATE)
          const certMatch = pemData.match(
            /-----BEGIN CERTIFICATE-----[\s\S]+?-----END CERTIFICATE-----/
          )
          // Extract private key (between BEGIN.*PRIVATE KEY and END.*PRIVATE KEY)
          const keyMatch = pemData.match(
            /-----BEGIN .*PRIVATE KEY-----[\s\S]+?-----END .*PRIVATE KEY-----/
          )

          if (certMatch && keyMatch) {
            // Pass as strings, not Buffers - Node.js handles PEM strings natively
            cert = certMatch[0] as any
            key = keyMatch[0] as any
            console.log('Extracted certificate and key from PEM file')
          } else {
            console.warn(
              'Could not parse PEM file (missing cert or key sections)'
            )
          }
        } else {
          console.warn('No client certificates found, attempting without auth')
        }
      }

      // Parse provider URI
      const providerUrl = new URL(providerUri)

      // Make authenticated request using https module
      const data = await new Promise<{
        forwarded_ports?: Record<string, Array<{ host: string; port: number }>>
        services?: Record<string, { uris?: string[] }>
      }>((resolve, reject) => {
        // Get passphrase from environment if available
        const keyPassphrase = process.env.AKASH_KEY_PASSPHRASE || ''

        const options: https.RequestOptions = {
          hostname: providerUrl.hostname,
          port: providerUrl.port || 8443,
          path: leaseStatusPath,
          method: 'GET',
          cert,
          key,
          passphrase: keyPassphrase,
          rejectUnauthorized: false, // Provider certs are often self-signed
          // For self-signed certificates, you can specify the CA cert explicitly:
          // ca: fs.readFileSync(pathToTrustedProviderCert)
        }

        const req = https.request(options, res => {
          if (res.statusCode !== 200) {
            reject(
              new Error(
                `Provider API returned ${res.statusCode}: ${res.statusMessage}`
              )
            )
            return
          }

          let body = ''
          res.on('data', chunk => {
            body += chunk
          })
          res.on('end', () => {
            try {
              resolve(JSON.parse(body))
            } catch (error) {
              reject(new Error(`Failed to parse response: ${error}`))
            }
          })
        })

        req.on('error', error => {
          // Provide helpful error message for common certificate issues
          if (
            error.message &&
            (error.message.includes('bad decrypt') ||
              error.message.includes('PKCS12'))
          ) {
            reject(
              new Error(
                `Certificate decryption failed: The private key appears to be encrypted. ` +
                  `Please set the AKASH_KEY_PASSPHRASE environment variable with the correct passphrase, ` +
                  `or use unencrypted certificates. Original error: ${error.message}`
              )
            )
          } else {
            reject(error)
          }
        })

        req.end()
      })

      const services: AkashService[] = []

      // Parse forwarded ports and extract service info
      if (data.forwarded_ports) {
        for (const [serviceName, ports] of Object.entries(
          data.forwarded_ports
        )) {
          const portInfo = ports as { host: string; port: number }[]
          if (portInfo.length > 0) {
            services.push({
              name: serviceName,
              externalIP: portInfo[0].host,
              port: portInfo[0].port,
              subdomain: '', // Will be set based on service name
            })
          }
        }
      }

      // Also check for services array if forwarded_ports is not present
      if (services.length === 0 && data.services) {
        for (const [serviceName, serviceData] of Object.entries(
          data.services
        )) {
          if (serviceData.uris && serviceData.uris.length > 0) {
            // Extract IP and port from URI
            const uri = serviceData.uris[0]
            const match = uri.match(/^(?:https?:\/\/)?([^:/]+):?(\d+)?/)
            if (match) {
              services.push({
                name: serviceName,
                externalIP: match[1],
                port: match[2] ? parseInt(match[2]) : 80,
                subdomain: '', // Will be set based on service name
              })
            }
          }
        }
      }

      return {
        dseq,
        provider,
        services,
      }
    } catch (error) {
      console.error('Failed to get Akash deployment details:', error)
      return null
    }
  }

  /**
   * Sync testnet DNS records for an Akash deployment
   */
  async syncTestnetDNS(
    dseq: string,
    provider: string
  ): Promise<DNSUpdateResult[]> {
    const deployment = await this.getDeploymentDetails(dseq, provider)
    if (!deployment) {
      return [{ success: false, error: 'Failed to get deployment details' }]
    }

    const results: DNSUpdateResult[] = []

    // Define testnet subdomain mapping
    const subdomainMap: Record<string, string> = {
      api: 'api-test',
      'yb-node-1': 'yb-test',
      ipfs: 'ipfs-test',
    }

    for (const service of deployment.services) {
      const subdomain = subdomainMap[service.name]
      if (!subdomain || !service.externalIP) {
        continue
      }

      console.log(
        `Syncing DNS for ${service.name}: ${subdomain} -> ${service.externalIP}`
      )

      const result = await this.dnsManager.updateAkashSubdomain(
        subdomain,
        service.externalIP,
        `http://${service.externalIP}:${service.port || 80}/health` // Optional health check
      )

      results.push(result)

      // Store DNS record info in service
      service.subdomain = subdomain
      service.dnsRecord = {
        name: subdomain,
        type: 'A',
        value: service.externalIP,
        ttl: 300,
      }
    }

    return results
  }

  /**
   * Sync mainnet DNS records for an Akash deployment
   */
  async syncMainnetDNS(
    dseq: string,
    provider: string
  ): Promise<DNSUpdateResult[]> {
    const deployment = await this.getDeploymentDetails(dseq, provider)
    if (!deployment) {
      return [{ success: false, error: 'Failed to get deployment details' }]
    }

    const results: DNSUpdateResult[] = []

    // Define mainnet subdomain mapping
    const subdomainMap: Record<string, string> = {
      api: 'api',
      'yb-node-1': 'yb',
      ipfs: 'ipfs',
    }

    for (const service of deployment.services) {
      const subdomain = subdomainMap[service.name]
      if (!subdomain || !service.externalIP) {
        continue
      }

      console.log(
        `Syncing DNS for ${service.name}: ${subdomain} -> ${service.externalIP}`
      )

      const result = await this.dnsManager.updateAkashSubdomain(
        subdomain,
        service.externalIP,
        `http://${service.externalIP}:${service.port || 80}/health` // Optional health check
      )

      results.push(result)

      // Wait for DNS propagation before moving to next service
      await this.dnsManager.waitForDNSPropagation(subdomain, service.externalIP)
    }

    return results
  }

  /**
   * Verify all DNS records for a deployment
   */
  async verifyDeploymentDNS(
    dseq: string,
    provider: string,
    isTestnet = true
  ): Promise<boolean> {
    const deployment = await this.getDeploymentDetails(dseq, provider)
    if (!deployment) {
      return false
    }

    const subdomainMap: Record<string, string> = isTestnet
      ? { api: 'api-test', 'yb-node-1': 'yb-test', ipfs: 'ipfs-test' }
      : { api: 'api', 'yb-node-1': 'yb', ipfs: 'ipfs' }

    for (const service of deployment.services) {
      const subdomain = subdomainMap[service.name]
      if (!subdomain || !service.externalIP) {
        continue
      }

      const check = await this.dnsManager.verifyDNSPropagation(
        subdomain,
        service.externalIP
      )
      if (!check.healthy) {
        console.error(`DNS verification failed for ${subdomain}:`, check)
        return false
      }
    }

    return true
  }

  /**
   * Export deployment DNS configuration
   */
  async exportDeploymentConfig(
    dseq: string,
    provider: string
  ): Promise<AkashDeployment | null> {
    return this.getDeploymentDetails(dseq, provider)
  }
}
