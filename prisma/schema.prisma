// Prisma Schema for AlternateFutures Platform
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER & AUTHENTICATION
// ============================================

model User {
  id            String   @id @default(cuid())
  email         String?  @unique
  username      String?  @unique
  walletAddress String?  @unique

  projects              Project[]
  personalAccessTokens  PersonalAccessToken[]
  agents                Agent[]
  chats                 Chat[]
  messages              Message[]
  customer              Customer?
  pinnedContent         PinnedContent[]
  storageSnapshots      StorageSnapshot[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([username])
  @@index([walletAddress])
}

model PersonalAccessToken {
  id         String    @id @default(cuid())
  name       String
  token      String    @unique

  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  expiresAt  DateTime?
  lastUsedAt DateTime?

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([userId])
  @@index([token])
}

// ============================================
// PROJECTS
// ============================================

model Project {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  sites     Site[]
  functions AFFunction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([slug])
}

// ============================================
// SITES & DEPLOYMENTS
// ============================================

model Site {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique

  projectId   String
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  deployments Deployment[]
  domains     Domain[]
  ipnsRecords IPNSRecord[]
  zones       Zone[]

  primaryDomainId String?
  primaryDomain   Domain? @relation("PrimaryDomain", fields: [primaryDomainId], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([projectId])
  @@index([slug])
}

model Deployment {
  id          String           @id @default(cuid())
  cid         String
  status      DeploymentStatus @default(PENDING)
  storageType StorageType      @default(IPFS)

  siteId      String
  site        Site             @relation(fields: [siteId], references: [id], onDelete: Cascade)

  pin         Pin?

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([siteId])
  @@index([cid])
  @@index([status])
}

enum DeploymentStatus {
  PENDING
  BUILDING
  UPLOADING
  SUCCESS
  FAILED
}

enum StorageType {
  IPFS
  ARWEAVE
  FILECOIN
}

// ============================================
// FUNCTIONS
// ============================================

model AFFunction {
  id                  String               @id @default(cuid())
  name                String
  slug                String               @unique
  invokeUrl           String?
  routes              Json?
  status              FunctionStatus       @default(ACTIVE)

  projectId           String
  project             Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)

  siteId              String?

  currentDeploymentId String?              @unique
  currentDeployment   AFFunctionDeployment? @relation("CurrentDeployment", fields: [currentDeploymentId], references: [id])

  deployments         AFFunctionDeployment[] @relation("FunctionDeployments")
  agents              Agent[]

  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt

  @@index([projectId])
  @@index([slug])
  @@index([status])
}

model AFFunctionDeployment {
  id              String         @id @default(cuid())
  cid             String
  blake3Hash      String?
  assetsCid       String?
  sgx             Boolean        @default(false)

  afFunctionId String
  afFunction   AFFunction  @relation("FunctionDeployments", fields: [afFunctionId], references: [id], onDelete: Cascade)

  currentFunction AFFunction? @relation("CurrentDeployment")

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([afFunctionId])
  @@index([cid])
}

enum FunctionStatus {
  ACTIVE
  INACTIVE
  DEPLOYING
  FAILED
}

// ============================================
// DOMAINS
// ============================================

model Domain {
  id          String       @id @default(cuid())
  hostname    String       @unique
  verified    Boolean      @default(false)
  domainType  DomainType   @default(WEB2)

  siteId      String
  site        Site         @relation(fields: [siteId], references: [id], onDelete: Cascade)

  primarySite Site[]       @relation("PrimaryDomain")

  // DNS Verification
  txtVerificationToken    String?   // Token to verify via TXT record
  txtVerificationStatus   VerificationStatus @default(PENDING)
  dnsVerifiedAt           DateTime?

  // DNS Records for verification
  expectedCname           String?   // Expected CNAME value
  expectedARecord         String?   // Expected A record value

  // SSL Certificate
  sslStatus               SslStatus @default(NONE)
  sslCertificateId        String?   // Let's Encrypt cert ID
  sslIssuedAt             DateTime?
  sslExpiresAt            DateTime?
  sslAutoRenew            Boolean   @default(true)

  // Web3 Domain Integration
  arnsName                String?   // ArNS name for Arweave
  arnsTransactionId       String?   // Arweave transaction ID
  ensName                 String?   // ENS domain name
  ensContentHash          String?   // ENS content hash
  ipnsHash                String?   // IPNS hash

  // DNS Propagation
  lastDnsCheck            DateTime?
  dnsCheckAttempts        Int       @default(0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([siteId])
  @@index([hostname])
  @@index([txtVerificationStatus])
  @@index([sslStatus])
  @@index([domainType])
}

enum DomainType {
  WEB2        // Traditional domain (example.com)
  ARNS        // Arweave Name System
  ENS         // Ethereum Name System
  IPNS        // InterPlanetary Name System
}

enum VerificationStatus {
  PENDING
  VERIFIED
  FAILED
}

enum SslStatus {
  NONE
  PENDING
  ACTIVE
  EXPIRED
  FAILED
}

model Zone {
  id        String   @id @default(cuid())
  name      String

  siteId    String
  site      Site     @relation(fields: [siteId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siteId])
}

// ============================================
// IPFS/STORAGE
// ============================================

model Pin {
  id           String     @id @default(cuid())
  cid          String     @unique
  name         String?
  size         Int?

  deploymentId String     @unique
  deployment   Deployment @relation(fields: [deploymentId], references: [id], onDelete: Cascade)

  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@index([cid])
}

model IPNSRecord {
  id        String   @id @default(cuid())
  name      String   @unique
  hash      String

  siteId    String
  site      Site     @relation(fields: [siteId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([siteId])
  @@index([name])
}

// ============================================
// AGENT CHAT SYSTEM
// ============================================

model Agent {
  id          String       @id @default(cuid())
  name        String
  slug        String       @unique
  description String?
  avatar      String?
  systemPrompt String?
  model       String       @default("gpt-4")
  status      AgentStatus  @default(ACTIVE)

  // Agent can be tied to a deployed function or external service
  functionId  String?
  afFunction  AFFunction?  @relation(fields: [functionId], references: [id], onDelete: SetNull)

  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  chats       Chat[]
  messages    Message[]

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([userId])
  @@index([slug])
  @@index([status])
  @@index([functionId])
}

enum AgentStatus {
  ACTIVE
  INACTIVE
  TRAINING
  ERROR
}

model Chat {
  id          String      @id @default(cuid())
  title       String?

  userId      String
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  agentId     String
  agent       Agent       @relation(fields: [agentId], references: [id], onDelete: Cascade)

  messages    Message[]
  attachments Attachment[]

  // Chat metadata
  metadata    Json?

  lastMessageAt DateTime?

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@index([userId])
  @@index([agentId])
  @@index([lastMessageAt])
}

model Message {
  id          String        @id @default(cuid())
  content     String
  role        MessageRole

  chatId      String
  chat        Chat          @relation(fields: [chatId], references: [id], onDelete: Cascade)

  // Agent that sent the message (if role is AGENT)
  agentId     String?
  agent       Agent?        @relation(fields: [agentId], references: [id], onDelete: SetNull)

  // User that sent the message (if role is USER)
  userId      String?
  user        User?         @relation(fields: [userId], references: [id], onDelete: SetNull)

  attachments Attachment[]

  // Message metadata (tokens used, model, etc.)
  metadata    Json?

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([chatId])
  @@index([agentId])
  @@index([userId])
  @@index([role])
  @@index([createdAt])
}

enum MessageRole {
  USER
  AGENT
  SYSTEM
}

model Attachment {
  id          String   @id @default(cuid())
  filename    String
  contentType String
  size        Int
  url         String

  // Could be stored on IPFS/Arweave
  cid         String?
  storageType StorageType?

  chatId      String?
  chat        Chat?    @relation(fields: [chatId], references: [id], onDelete: Cascade)

  messageId   String?
  message     Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([chatId])
  @@index([messageId])
  @@index([cid])
}

// ============================================
// BILLING SYSTEM
// ============================================

model Customer {
  id                String   @id @default(cuid())

  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Stripe customer ID
  stripeCustomerId  String?  @unique

  // Billing details
  email             String?
  name              String?
  address           Json?    // { line1, line2, city, state, postal_code, country }

  // Default payment method
  defaultPaymentMethodId String?
  defaultPaymentMethod   PaymentMethod? @relation("DefaultPaymentMethod", fields: [defaultPaymentMethodId], references: [id])

  paymentMethods    PaymentMethod[] @relation("CustomerPaymentMethods")
  subscriptions     Subscription[]
  invoices          Invoice[]
  payments          Payment[]
  usageRecords      UsageRecord[]

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([userId])
  @@index([stripeCustomerId])
}

model PaymentMethod {
  id                String              @id @default(cuid())

  customerId        String
  customer          Customer            @relation("CustomerPaymentMethods", fields: [customerId], references: [id], onDelete: Cascade)

  type              PaymentMethodType

  // For Stripe credit cards
  stripePaymentMethodId String?         @unique
  cardBrand         String?             // visa, mastercard, amex, etc.
  cardLast4         String?
  cardExpMonth      Int?
  cardExpYear       Int?

  // For crypto wallets
  walletAddress     String?
  blockchain        String?             // ethereum, solana, arweave, filecoin

  isDefault         Boolean             @default(false)

  defaultForCustomers Customer[]        @relation("DefaultPaymentMethod")
  payments          Payment[]

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([customerId])
  @@index([stripePaymentMethodId])
  @@index([walletAddress])
}

enum PaymentMethodType {
  CARD
  CRYPTO_WALLET
}

model Subscription {
  id                String             @id @default(cuid())

  customerId        String
  customer          Customer           @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Stripe subscription ID
  stripeSubscriptionId String?         @unique

  status            SubscriptionStatus @default(ACTIVE)
  plan              SubscriptionPlan

  // Pricing
  basePricePerSeat  Decimal            // Admin-configurable per seat price
  usageMarkup       Decimal            // Admin-configurable percentage markup on usage (0.0-1.0)

  // Seats
  seats             Int                @default(1)

  // Billing period
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime

  // Cancellation
  cancelAt          DateTime?
  canceledAt        DateTime?

  invoices          Invoice[]

  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@index([customerId])
  @@index([status])
  @@index([stripeSubscriptionId])
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
  PAUSED
}

enum SubscriptionPlan {
  FREE
  STARTER
  PRO
  ENTERPRISE
}

model Invoice {
  id                String           @id @default(cuid())

  customerId        String
  customer          Customer         @relation(fields: [customerId], references: [id], onDelete: Cascade)

  subscriptionId    String?
  subscription      Subscription?    @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  // Stripe invoice ID
  stripeInvoiceId   String?          @unique

  // Invoice details
  invoiceNumber     String           @unique
  status            InvoiceStatus    @default(DRAFT)

  // Amounts (in cents/smallest currency unit)
  subtotal          Int              // Base subscription + usage charges
  tax               Int              @default(0)
  total             Int
  amountPaid        Int              @default(0)
  amountDue         Int

  currency          String           @default("usd")

  // Billing period
  periodStart       DateTime
  periodEnd         DateTime

  // Due date and payment
  dueDate           DateTime?
  paidAt            DateTime?

  // PDF generation
  pdfUrl            String?

  lineItems         InvoiceLineItem[]
  payments          Payment[]

  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  @@index([customerId])
  @@index([subscriptionId])
  @@index([status])
  @@index([invoiceNumber])
  @@index([stripeInvoiceId])
}

enum InvoiceStatus {
  DRAFT
  OPEN
  PAID
  VOID
  UNCOLLECTIBLE
}

model InvoiceLineItem {
  id          String   @id @default(cuid())

  invoiceId   String
  invoice     Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  description String
  quantity    Decimal
  unitPrice   Int      // in cents
  amount      Int      // in cents

  // Metadata for usage-based items
  metadata    Json?    // { usageType, resourceId, etc. }

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([invoiceId])
}

model Payment {
  id                String        @id @default(cuid())

  customerId        String
  customer          Customer      @relation(fields: [customerId], references: [id], onDelete: Cascade)

  invoiceId         String?
  invoice           Invoice?      @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  paymentMethodId   String?
  paymentMethod     PaymentMethod? @relation(fields: [paymentMethodId], references: [id], onDelete: SetNull)

  // Stripe payment intent ID
  stripePaymentIntentId String?   @unique

  // Crypto transaction hash
  txHash            String?       @unique
  blockchain        String?

  amount            Int           // in cents or smallest currency unit
  currency          String        @default("usd")

  status            PaymentStatus @default(PENDING)

  // Failure information
  failureCode       String?
  failureMessage    String?

  // Metadata
  metadata          Json?

  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  @@index([customerId])
  @@index([invoiceId])
  @@index([status])
  @@index([stripePaymentIntentId])
  @@index([txHash])
}

enum PaymentStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELED
  REFUNDED
}

model UsageRecord {
  id          String      @id @default(cuid())

  customerId  String
  customer    Customer    @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Usage type
  type        UsageType

  // Resource being metered
  resourceType String     // deployment, function, bandwidth, etc.
  resourceId   String?    // ID of deployment, function, etc.

  // Usage amount
  quantity    Decimal
  unit        String      // bytes, requests, hours, etc.

  // Timestamp
  timestamp   DateTime    @default(now())

  // Billing period
  periodStart DateTime
  periodEnd   DateTime

  // Cost calculation
  unitPrice   Int?        // in cents
  amount      Int?        // in cents

  // Metadata
  metadata    Json?

  createdAt   DateTime    @default(now())

  @@index([customerId])
  @@index([type])
  @@index([resourceType])
  @@index([resourceId])
  @@index([timestamp])
  @@index([periodStart, periodEnd])
}

enum UsageType {
  STORAGE
  BANDWIDTH
  COMPUTE
  REQUESTS
  SEATS
}

model BillingSettings {
  id                    String   @id @default(cuid())

  // Per-seat pricing
  pricePerSeatCents     Int      @default(0)

  // Usage markup percentage (0.0 to 1.0)
  usageMarkupPercent    Decimal  @default(0.0)

  // Usage pricing (in cents per unit)
  storagePerGBCents     Int      @default(0)
  bandwidthPerGBCents   Int      @default(0)
  computePerHourCents   Int      @default(0)
  requestsPer1000Cents  Int      @default(0)

  // Tax settings
  taxRatePercent        Decimal  @default(0.0)

  // Invoice settings
  invoiceDueDays        Int      @default(30)

  // Trial period (in days)
  trialPeriodDays       Int      @default(0)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

// ============================================
// STORAGE TRACKING
// ============================================

model PinnedContent {
  id          String    @id @default(cuid())

  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // IPFS Content Identifier (immutable)
  cid         String

  // Size in bytes (immutable for this CID)
  sizeBytes   BigInt

  // Pin tracking
  pinnedAt    DateTime  @default(now())
  unpinnedAt  DateTime? // Null if still pinned

  // Optional metadata
  filename    String?
  mimeType    String?
  metadata    Json?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([cid])
  @@index([userId, unpinnedAt]) // For quick active pins query
  @@index([pinnedAt])
  @@index([unpinnedAt])
}

model StorageSnapshot {
  id          String   @id @default(cuid())

  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Snapshot date (daily)
  date        DateTime

  // Total storage at this date
  totalBytes  BigInt

  // Pin count
  pinCount    Int

  createdAt   DateTime @default(now())

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
}
